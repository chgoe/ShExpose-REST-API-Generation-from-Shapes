import {ShapeDecl} from "shexj";
import * as yaml from 'js-yaml';
import fs from 'node:fs/promises';
import { languagesOf } from "@ldo/ldo";
import type { LdoJsonldContext } from "@ldo/jsonld-dataset-proxy";


const XSD = "http://www.w3.org/2001/XMLSchema#";
const RDF_LANGSTRING = "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString";

/**
 * Flattens a type-scoped LDO context into a flat context.
 * 
 * LDO generates contexts with type-scoped definitions for every shape.
 * Since a shape may be related to other shapes, it does not seem to "know" which shape we want to instantiate.
 * 
 * Mitigation: Flatten the context, so that it contains all properties at the top level.
 * This way, when creating a new object, all properties are known.
 * 
 * @param scopedContext - ShapeType-scoped context generated by LDO
 * @returns flattened context, with all properties at the top level
 */
export function flattenLdoContext(scopedContext: LdoJsonldContext): LdoJsonldContext {
    const flatContext: Record<string, any> = {};
    
    for (const [typeName, typeDefinition] of Object.entries(scopedContext)) {
        if (typeof typeDefinition === 'object' && typeDefinition !== null) {
            const typeDef = typeDefinition as Record<string, any>;

            if ('@context' in typeDef && typeof typeDef['@context'] === 'object' && typeDef['@context'] !== null) {
                // typed objects where LDO switches to the type-scoped context.
                // augmented type-scoped context contains URI local name aliases
                // otherwise LDO will not work as expected with our setValue()
                const augmentedTypeContext: Record<string, any> = {};

                for (const [propName, propDef] of Object.entries(typeDef['@context'] as Record<string, any>)) {
                    // keep existing properties, i.e., type and shared properties
                    if (!(propName in flatContext)) {
                        flatContext[propName] = propDef;
                    }
                    // register alias to URIs local name which is derived by setValue() (split on '#' first, then '/')
                    // otherwise, LDOs proxy will not be able to resolve back to the full URI
                    augmentedTypeContext[propName] = propDef;
                    if (propDef && typeof propDef === 'object' && typeof propDef['@id'] === 'string' && propDef['@id'] !== '@type') {
                        const uri = propDef['@id'] as string;
                        const localName = uri.split('#')[1] ?? uri.split('/').slice(-1)[0];
                        if (localName && localName !== propName) {
                            if (!(localName in flatContext)) {
                                flatContext[localName] = propDef;
                            }
                            if (!(localName in augmentedTypeContext)) {
                                augmentedTypeContext[localName] = propDef;
                            }
                        }
                    }
                }

                // keep type definition
                // replace @context with augmented type context
                flatContext[typeName] = { ...typeDef, '@context': augmentedTypeContext };
            } else if ('@id' in typeDef) {
                flatContext[typeName] = typeDef['@id'];
            }
        }
    }
    return flatContext as LdoJsonldContext;
}

interface OverwriteMapping {
    path: string[];
    name: string;
}

interface OverwriteConfig {
    overwriteMappings: OverwriteMapping[];
}

export class ArrayKeyedMap {
    private map: Map<string, string>;
    
    constructor() {
        this.map = new Map<string, string>();
    }
    
    stringifyKey(key: Array<string>) { return JSON.stringify(key); }
    get(key: Array<string>) { return this.map.get(this.stringifyKey(key)); }
    set(key: Array<string>, value: string) { this.map.set(this.stringifyKey(key), value); return this; }
    has(key: Array<string>) { return this.map.has(this.stringifyKey(key)); }
}

export async function loadOverwriteMappings(configPath: string): Promise<ArrayKeyedMap> {
    try {
        const configContent = await fs.readFile(configPath, { encoding: 'utf8' });
        const config = yaml.load(configContent) as OverwriteConfig;
        
        const overwriteMap = new ArrayKeyedMap();
        
        if (config.overwriteMappings) {
            for (const mapping of config.overwriteMappings) {
                overwriteMap.set(mapping.path, mapping.name);
            }
        }
        
        return overwriteMap;
    } catch (err) {
        console.error(`Error loading overwrite mappings from ${configPath}:`, err);
        return new ArrayKeyedMap(); // Return empty map on error
    }
}

function _findPredicatesForShape(shapeId: string,
                                shapes: ShapeDecl[]|undefined,
                                context: {[index: string]: any},
                                overwriteMap: ArrayKeyedMap,
                                currentPath: Array<string> = []): {[index: string]: {[index: string]: Array<string>}} {
    if (shapes === undefined) {
        console.error(`shapes is undefined, abort.`);
        return {};
    }

    const shape = shapes.find(s => s.id === shapeId);
    if (!shape) {
        console.error(`Shape with id ${shapeId} not found.`);
        return {};
    }

    let result: {[index: string]: {[index: string]: Array<string>}} = {};

    function traverseExpressions(expressions: Array<any>, currentPath: Array<string>) {
        if (expressions === undefined)
            return

        expressions.forEach(expr => {
            if (expr.type === "TripleConstraint") {
                const predicate = expr.predicate;
                const path: Array<string> = [...currentPath, predicate];

                for (let key in context) {
                    if (context[key]["@id"] === predicate &&
                        "@type" in context[key] &&
                        (context[key]["@type"].includes(XSD) || context[key]["@type"] === RDF_LANGSTRING)) {
                        const pathKey = path.join('|');
                        
                        if (overwriteMap.has(path)) {
                            const customName = overwriteMap.get(path);
                            if (customName) {
                                result[customName] = { path: path };
                            }
                        } else {
                            result[pathKey] = { path: path };
                        }
                    }
                }

                // if other shapes are referenced, traverse them as well
                if (expr.valueExpr) {
                    let nestedShapeId: string | null = null;
                    if (typeof expr.valueExpr === "string") {
                        nestedShapeId = expr.valueExpr;
                    } else if (expr.valueExpr.type === "ShapeRef" && expr.valueExpr.reference) {
                        nestedShapeId = expr.valueExpr.reference;
                    }
                    
                    if (nestedShapeId) {
                        const nestedPredicates = _findPredicatesForShape(nestedShapeId, shapes, context, overwriteMap, path);
                        Object.assign(result, nestedPredicates);
                    }
                }
            } else if (expr.expressions) {
                // If there are nested expressions (EachOf), traverse them recursively
                traverseExpressions(expr.expressions, currentPath);
            }
        });
    }

    if (shape.shapeExpr &&
          "expression" in shape.shapeExpr &&
          shape.shapeExpr.expression &&
          typeof shape.shapeExpr.expression === "object" &&
          "expressions" in shape.shapeExpr.expression &&
          shape.shapeExpr.expression.expressions) {
        traverseExpressions(shape.shapeExpr.expression.expressions, currentPath);
    }

    return result;
}

export function findPredicatesForShape(shapeId: string,
                                shapes: ShapeDecl[]|undefined,
                                context: {[index: string]: any},
                                overwriteMap: ArrayKeyedMap,
                                currentPath: Array<string> = []): {[index: string]: {[index: string]: Array<string>}} {
    /*
    Flattens the nested context structure by extracting all properties from each shape's @context
    and merging them into a single flat object.
    This is necessary because the structure of the context has changed in the last LDO versions...
    */
    let mergedContext: {[index: string]: any} = {};
    
    for (let shapeKey in context) {
        const shape = context[shapeKey];
        
        if (shape && typeof shape === 'object' && '@context' in shape) {
            const shapeContext = shape['@context'];
            
            // merge all properties from this shape's @context into mergedContext
            if (shapeContext && typeof shapeContext === 'object') {
                for (let propertyKey in shapeContext) {
                    // only add if not already present => assuming that each key has the same URI
                    if (!(propertyKey in mergedContext)) {
                        mergedContext[propertyKey] = shapeContext[propertyKey];
                    }
                }
            }
        }
    }
    
    return _findPredicatesForShape(shapeId, shapes, mergedContext, overwriteMap, currentPath);
}

export function extractTypeUri(schema: any, startShapeUri: string): string | undefined {
    const RDF_TYPE = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";
    const startShape = schema.shapes?.find((s: any) => s.id === startShapeUri);
    if (!startShape) return undefined;

    function findType(expr: any): string | undefined {
        if (!expr) return undefined;
        if (expr.type === "TripleConstraint" && expr.predicate === RDF_TYPE) {
            return expr.valueExpr?.values?.[0];
        }
        if (expr.expressions) {
            for (const e of expr.expressions) {
                const result = findType(e);
                if (result) return result;
            }
        }
        return undefined;
    }

    return findType(startShape.shapeExpr?.expression);
}

/**
 * Builds a map from predicate path prefixes to the rdf:type URI of the
 * intermediate shapes they reference.
 *
 * For example, if the start shape has:
 *   vivo:dateTimeInterval @<DateTimeInterval>
 * and <DateTimeInterval> declares rdf:type [vivo:DateTimeInterval],
 * then the map will contain:
 *   ["http://vivoweb.org/ontology/core#dateTimeInterval"] → "http://vivoweb.org/ontology/core#DateTimeInterval"
 *
 * @param schema  The parsed ShEx schema (with .shapes and .start)
 * @param startShapeUri  The URI of the start shape
 * @returns A Map keyed by JSON.stringify(predicatePath) → typeUri
 */
export function buildIntermediateTypeMap(
    schema: any,
    startShapeUri: string
): Map<string, string> {
    const RDF_TYPE = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";
    const result = new Map<string, string>();
    const visited = new Set<string>();

    function traverse(shapeUri: string, currentPath: string[]) {
        if (visited.has(shapeUri)) return;
        visited.add(shapeUri);

        const shape = schema.shapes?.find((s: any) => s.id === shapeUri);
        if (!shape?.shapeExpr?.expression) return;

        function walkExpressions(expressions: any[]) {
            if (!expressions) return;
            for (const expr of expressions) {
                if (expr.type === "TripleConstraint" && expr.predicate !== RDF_TYPE) {
                    let nestedShapeUri: string | null = null;
                    if (typeof expr.valueExpr === "string") {
                        nestedShapeUri = expr.valueExpr;
                    } else if (expr.valueExpr?.type === "ShapeRef" && expr.valueExpr?.reference) {
                        nestedShapeUri = expr.valueExpr.reference;
                    }
                    if (nestedShapeUri) {
                        const nestedPath = [...currentPath, expr.predicate];
                        // extract rdf:type from the referenced shape
                        const typeUri = extractTypeUri(schema, nestedShapeUri);
                        if (typeUri) {
                            result.set(JSON.stringify(nestedPath), typeUri);
                        }
                        traverse(nestedShapeUri, nestedPath);
                    }
                } else if (expr.expressions) {
                    walkExpressions(expr.expressions);
                }
            }
        }

        const topExpr = shape.shapeExpr.expression;
        if (topExpr.expressions) {
            walkExpressions(topExpr.expressions);
        } else if (topExpr.type === "TripleConstraint") {
            walkExpressions([topExpr]);
        }
    }

    traverse(startShapeUri, []);
    return result;
}
